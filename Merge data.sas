/****************************************************************************************/ 
/* This SAS-program constructs the estimation data set. The program is structured in 4  */
/* steps:                                                                               */ 
/* Step 1: For each tiar (1984-2005) this step merges data on tax liability status with */
/*         data generated by the programs "TAXSIM1984-2005" and                         */
/*         "TAXSIM1984-2005_Mechanical", rename variables and price-adjust incomes.     */
/* Step 2: Using data from step 1, this step merges data for tiar t with data for tiar  */ 
/*         t+3 and select the estimation sample.                                        */
/* Step 3: Using data from step 2, this step constructs income and tax variables for    */
/*         estimation for each tiar.                                                    */
/* Step 4: Using data from step 3 and administrative data on municipality of living,    */
/*         this step merges tiarly datasets into one dataset, add socioeconomic         */ 
/*         controls and construct income controls.                                      */
/****************************************************************************************/
options obs=max;
options mergenoby=error;
*********HER KAN INDSTILLINGER VÆLGES HVIS PROGRAMMET IKKE KØRES VIA PROCEDUREBOGEN******;
%let date = %sysfunc(today(),ddmmyyn6.);

%let inf_type=Lon;
*%Let inf_type=Pris;
*%Let inf_type=Regulerings;

%Let PSTILL_KEEP=(1:99); *1:37 = beskæftigede.  1:99 = alle; *ANLUJ: Dette er slået fra i programmet, da det ikke virker fra 2005 og frem,
															 idet PSTILL erstattes af psoc_status_kode som har andre værdier (ikke relevant hvis vi bruger overfor1 og 3); 
%Let Alder_keep=(15:70);
%let indkomstbegreb=LOENMV_13;

*******************************FORMATER*******************************************************;
libname fmt 'D:\DOKUMENTATION\SAS formater i Danmarks Statistik\FORMATKATALOG' access=readonly;
libname fmt2 'Y:\Projekt\OIM\MORA\Genestimation\Data\Diverse' access=readonly;
Options fmtsearch=(fmt2.uddannelse fmt.times_personstatistik fmt.disced fmt.uddannelser);

*******************************DATA***********************************************************;
libname marg   ("Y:\Projekt\OIM\MORA\Genestimation\Data\TAXSIM\&indkomstbegreb.\100%",
				"Y:\Projekt\OIM\MORA\Genestimation\Data\Mechanical\3 AAR STIK\100%",
				"Y:\Projekt\OIM\MORA\Genestimation\Data\Mechanical\4 AAR STIK\100%",
				"Y:\Projekt\OIM\MORA\Genestimation\Data\Mechanical\5 AAR STIK\100%",);
;
libname div		"Y:\Projekt\OIM\MORA\Genestimation\Data\Diverse";
libname ud		"Y:\Projekt\OIM\MORA\Genestimation\Data\Estimationsresultater";			 		


%let infsti=Y:\Projekt\OIM\MORA\Genestimation\Data\Diverse;
**********************************************************************************************;



* STEP 0: IMPORTERER INFLATION OG LAVER DATASÆTTET SÅ DET KAN BRUGES. DET ER RIMELIG UPRAKTISK, MEN SÅDAN ER RESTEN AF K&S' KODE PROGRAMMERET******************;
proc import datafile="&infsti.\&inf_type.Indeks_2005=1.txt" out=inflation (keep=tiar indeks) dbms=dlm replace;
delimiter='09'x;
run;
*Laver diagonalmatrice med 1-taller i diagonalen. Bruges til at kalde i den rigtige inflation (i stedet for at bruge where tiar=xxxx);
data inflation; set inflation;
array emptyvar infl1984-infl2016;
do j = 1 to (2016-1984+1);
	emptyvar(j) = 0;
if j =_n_ then emptyvar(j)=1;
end;
drop j;
run;
*Giver dem de rigtige navne - det er en makro der tilføjer '_2005' til alle variable der hedder inflationYYYY;
proc sql noprint;
select cats(name,'=',name,'_2005')
into :list
separated by ' '
from dictionary.columns 
where libname = 'WORK' and memname = 'INFLATION'
and upcase(name) like 'INFL%';
quit; 
proc datasets library=work nolist;
modify inflation;
rename &list;
quit;
data div.inflation; set inflation;
inflation=1/indeks;
drop indeks;
run;
proc datasets library=work nolist kill;
quit;
*************************************************** SLUT PÅ STEP 0 *******************************************;


* STEP 1: FOR EACH YEAR (1984-2016) THIS STEP MERGES DATA ON TAX LIABILITY STATUS WITH DATA GENERATED BY THE
           PROGRAMS "TAXSIM1984-2016" AND "MEC_TAXSIM1984-2016", RENAME VARIABLES AND PRICE-ADJUST INCOMES **;

%macro step1;
%do aar = 1987 %to 2016; *1984-2016 er alle år; *ANLUJ: Hvis vi kun vil have år med god data (uden differens til før 87) er 1987-2016 fuld periode;

%let aar_2=%eval(&aar.-2); *Til -2års inflation;
%let aar_1=%eval(&aar.-1); *Til -1års inflation;
*%let aar1=%eval(&aar.+1); *Til 1års inflation;
*%let aar2=%eval(&aar.+2); *Til 2års inflation;
%let aar3=%eval(&aar.+3); *Til 3års inflation;

libname ft "x:\MB\Fuldtællinger\&aar." access=readonly;


*ANLUJ: Starter med de 2 første år, hvor vi ikke skal bruge instrimenter (dvs. 1987-1988);
%if &aar <= 1988 %then %do; *Herfra henter vi ikke mekaniske ændringer;
data ska&aar.;
merge marg.skat&aar.(in=a) ft.ind (keep=id_nr omfskpl in=b);
by id_nr;
if a=1 and b=1;
if kon=1 then mand=1; else mand=0;
drop kon;
run;

data k(keep=tiar inflation&aar._2005);
set div.inflation(where=(infl&aar._2005=1));
inflation&aar._2005=inflation;
run;

data skat&aar.(drop=per cap dec ear c_per c_cap c_dec c_ear per_income c_per_income  virtuelindk_i virtuelindk_h1
virtuelindk_h2 tax1 c_tax1);
merge ska&aar.(in=a) k(in=b);
by tiar;
if omfskpl=0 then spligt&aar.=1; else spligt&aar.=0;
per_&aar.=per*inflation&aar._2005;
cap_&aar.=cap*inflation&aar._2005;
dec_&aar.=dec*inflation&aar._2005;
ear_&aar.=ear*inflation&aar._2005;
c_per_&aar.=c_per*inflation&aar._2005;
c_cap_&aar.=c_cap*inflation&aar._2005;
c_dec_&aar.=c_dec*inflation&aar._2005;
c_ear_&aar.=c_ear*inflation&aar._2005;
per_income_&aar.=per_income*inflation&aar._2005;
c_per_income_&aar.=c_per_income*inflation&aar._2005;
virtuelindk_i_&aar.=virtuelindk_i*inflation&aar._2005;
virtuelindk_h1_&aar.=virtuelindk_h1*inflation&aar._2005;
virtuelindk_h2_&aar.=virtuelindk_h2*inflation&aar._2005;
tax1_&aar.=tax1*inflation&aar._2005;
c_tax1_&aar.=c_tax1*inflation&aar._2005;
/*akt_&aar.=aktind*inflation&aar._2005;*/
/*c_akt_&aar.=c_aktind*inflation&aar._2005;*/
rename tau_arb_i=tau_arb_i&aar. 
       tau_apers_i=tau_apers_i&aar.
       tau_kap_i=tau_kap_i&aar.
	   tau_frad_i=tau_frad_i&aar.
	   tau_arb_h=tau_arb_h&aar. 
       tau_apers_h=tau_apers_h&aar.
       tau_kap_h=tau_kap_h&aar.
	   tau_frad_h=tau_frad_h&aar.
	   c_tau_arb_i=c_tau_arb_i&aar. 
       c_tau_apers_i=c_tau_apers_i&aar.
       c_tau_kap_i=c_tau_kap_i&aar.
	   c_tau_frad_i=c_tau_frad_i&aar.
	   c_tau_arb_h=c_tau_arb_h&aar. 
       c_tau_apers_h=c_tau_apers_h&aar.
       c_tau_kap_h=c_tau_kap_h&aar.
	   c_tau_frad_h=c_tau_frad_h&aar.
/*	   tau_akt_h=tau_akt_h&aar.*/
/*	   c_tau_akt_h=c_tau_akt_h&aar.*/
	 
	   /*gift=gift&aar.*/;
	   if a=1 and b=1;
run;
%end; *Slut på 1987-1988 hvor der ikke hentes instrumenter;


*ANLUJ: Starter den store løkke, hvor alle instrumenter indlæses og navngives efter år (fra -2 til 3);
%if &aar. >= 1989 and &aar. <= 2013 %then %do;
	%let list=&aar_2 &aar_1 /*&aar1 &aar2*/ &aar;
	%do i=1 %to 3;
		%let aarX=%scan(&list.,&i.);

		data tmp_skat&aar3._indkomst&aarx.;
		set marg.skat&aar3._indkomst&aarX.
		(keep=id_nr tau_arb_i tau_apers_i tau_kap_i tau_frad_i tau_arb_h tau_apers_h tau_kap_h
		tau_frad_h c_tau_arb_i c_tau_apers_i c_tau_kap_i c_tau_frad_i c_tau_arb_h c_tau_apers_h
		c_tau_kap_h c_tau_frad_h /*tau_akt_h c_tau_akt_h*/ virtuelindk_i virtuelindk_h1 virtuelindk_h2 
		top_dummy mellem_dummy bund_dummy notax_dummy
		rename=(
		tau_arb_i=tau_arb_i_mec_&aarX.
		tau_apers_i=tau_apers_i_mec_&aarX.
		tau_kap_i=tau_kap_i_mec_&aarX.
		tau_frad_i=tau_frad_i_mec_&aarX.
		tau_arb_h=tau_arb_h_mec_&aarX.
		tau_apers_h=tau_apers_h_mec_&aarX.
		tau_kap_h=tau_kap_h_mec_&aarX.
		tau_frad_h=tau_frad_h_mec_&aarX.
/*		tau_akt_h=tau_akt_h_mec_&aarX.*/
		c_tau_arb_i=c_tau_arb_i_mec_&aarX. 
		c_tau_apers_i=c_tau_apers_i_mec_&aarX.
		c_tau_kap_i=c_tau_kap_i_mec_&aarX.
		c_tau_frad_i=c_tau_frad_i_mec_&aarX.
		c_tau_arb_h=c_tau_arb_h_mec_&aarX.
		c_tau_apers_h=c_tau_apers_h_mec_&aarX.
		c_tau_kap_h=c_tau_kap_h_mec_&aarX.
		c_tau_frad_h=c_tau_frad_h_mec_&aarX.
/*		c_tau_akt_h=c_tau_akt_h_mec_&aarX.*/
		virtuelindk_i=virtuelindk_i_mec_&aarX.
		virtuelindk_h1=virtuelindk_h1_mec_&aarX. 
		virtuelindk_h2=virtuelindk_h2_mec_&aarX. 
		top_dummy=top_dummy_mec_&aarX. 
		mellem_dummy=mellem_dummy_mec_&aarX. 
		bund_dummy=bund_dummy_mec_&aarX. 
		notax_dummy=notax_dummy_mec_&aarX.));
		run;
	%end; *Slut på 1 to 5 loop der indlæser de forskellige typer instrumenter;
Data inst_indkomst&aar.; Merge tmp:; 
by id_nr;
run;

proc datasets lib=work nolist;
delete tmp:;
run;

%if &aar. <2002 %then %do;
data ska&aar.;
merge marg.skat&aar.(in=a) inst_indkomst&aar. (in=b) 
 ft.ind (keep=id_nr omfskpl in=c);
by id_nr;
if a=1 and b=1 and c=1;

if kon=1 then mand=1; else mand=0;
drop kon;
run;
%end;

%if &aar. >=2002 %then %do;
data ska&aar. (drop=omfang);
merge marg.skat&aar.(in=a) inst_indkomst&aar. (in=b) 
 ft.ind (keep=id_nr omfang in=c);
by id_nr;
if a=1 and b=1 and c=1;
if omfang=1 then omfskpl=0; else omfskpl=1;
if kon=1 then mand=1; else mand=0;
drop kon;
run;
%end;

data tmp&aar. (keep=tiar inflation&aar._2005);
set div.inflation(where=(infl&aar._2005=1));
inflation&aar._2005=inflation;
run;

%do i=1 %to 3;
	%let aarX = %scan(&list.,&i.);

	data tmp&aarX.(keep=tiar inflation&aarX._2005);
	set div.inflation(where=(infl&aarX._2005=1));
	inflation&aarX._2005=inflation;
	tiar=&aar.;
	run;
%end;

data inf&aar.; merge tmp:;
by tiar;
run;
proc datasets lib=work nolist;
delete tmp:;
run;

data skat&aar.(drop=per cap dec ear c_per c_cap c_dec c_ear per_income c_per_income virtuelindk_i virtuelindk_h1
virtuelindk_h2 tax1 c_tax1 nybundinc nymelleminc nytopinc);
merge ska&aar.(in=a) inf&aar. (in=b);
by tiar;
tt=0;
tm=0;
tb=0;
tn=0;
mt=0;
mm=0;
mb=0;
mn=0;
bt=0;
bm=0;
bb=0;
bn=0;
nt=0;
nm=0;
nb=0;
nn=0;
/*top*/
if top_dummy=1 and top_dummy_mec_&aar3.=1 then tt=1;  
if top_dummy=1 and mellem_dummy_mec_&aar3.=1 then tm=1; 
if top_dummy=1 and bund_dummy_mec_&aar3.=1 then tb=1; 
if top_dummy=1 and notax_dummy_mec_&aar3.=1 then tn=1; 
/*mellem*/
if mellem_dummy=1 and top_dummy_mec_&aar3.=1 then mt=1; 
if mellem_dummy=1 and mellem_dummy_mec_&aar3.=1 then mm=1; 
if mellem_dummy=1 and bund_dummy_mec_&aar3.=1 then mb=1; 
if mellem_dummy=1 and notax_dummy_mec_&aar3.=1 then mn=1; 
/*bund*/
if bund_dummy=1 and top_dummy_mec_&aar3.=1 then bt=1; 
if bund_dummy=1 and mellem_dummy_mec_&aar3.=1 then bm=1; 
if bund_dummy=1 and bund_dummy_mec_&aar3.=1 then bb=1; 
if bund_dummy=1 and notax_dummy_mec_&aar3.=1 then bn=1; 
/*notax*/
if notax_dummy=1 and bund_dummy_mec_&aar3.=1 then nb=1;
if notax_dummy=1 and notax_dummy_mec_&aar3.=1 then nn=1;
if notax_dummy=1 and mellem_dummy_mec_&aar3.=1 then nm=1;
if notax_dummy=1 and top_dummy_mec_&aar3.=1 then nt=1;

if exp=. then exp=0;
if omfskpl=0 then spligt&aar.=1; else spligt&aar.=0;
bkink=nybundinc*inflation&aar._2005;
mkink=nymelleminc*inflation&aar._2005;
tkink=nytopinc*inflation&aar._2005;
per_&aar.=per*inflation&aar._2005;
cap_&aar.=cap*inflation&aar._2005;
dec_&aar.=dec*inflation&aar._2005;
ear_&aar.=ear*inflation&aar._2005;
per_income_&aar.=per_income*inflation&aar._2005;
c_per_income_&aar.=c_per_income*inflation&aar._2005;
c_per_&aar.=c_per*inflation&aar._2005;
c_cap_&aar.=c_cap*inflation&aar._2005;
c_dec_&aar.=c_dec*inflation&aar._2005;
c_ear_&aar.=c_ear*inflation&aar._2005;
virtuelindk_i_&aar.=virtuelindk_i*inflation&aar._2005;
virtuelindk_h1_&aar.=virtuelindk_h1*inflation&aar._2005;
virtuelindk_h2_&aar.=virtuelindk_h2*inflation&aar._2005;
virtuelindk_i_mec_&aar_2.=virtuelindk_i_mec_&aar_2.*inflation&aar_2._2005;   *		(-2)   ANLUJ: Rettet så inflationen afhænger af hvor mange års differens instrumentet er;
virtuelindk_h1_mec_&aar_2.=virtuelindk_h1_mec_&aar_2.*inflation&aar_2._2005; *ditto  (-2)  (Da det har betydning for hvor mange år det er blevet regnet frem i mechanical programmet);
virtuelindk_h2_mec_&aar_2.=virtuelindk_h2_mec_&aar_2.*inflation&aar_2._2005; *ditto. (-2);
virtuelindk_i_mec_&aar_1.=virtuelindk_i_mec_&aar_1.*inflation&aar_1._2005;   *ditto. (-1);
virtuelindk_h1_mec_&aar_1.=virtuelindk_h1_mec_&aar_1.*inflation&aar_1._2005; *ditto. (-1);
virtuelindk_h2_mec_&aar_1.=virtuelindk_h2_mec_&aar_1.*inflation&aar_1._2005; *ditto. (-1);
/*virtuelindk_i_mec_&aar1.=virtuelindk_i_mec_&aar1.*inflation&aar1._2005;      *ditto. (1);*/
/*virtuelindk_h1_mec_&aar1.=virtuelindk_h1_mec_&aar1.*inflation&aar1._2005;    *ditto. (1);*/
/*virtuelindk_h2_mec_&aar1.=virtuelindk_h2_mec_&aar1.*inflation&aar1._2005;    *ditto. (1);*/
/*virtuelindk_i_mec_&aar2.=virtuelindk_i_mec_&aar2.*inflation&aar2._2005;      *ditto. (2);*/
/*virtuelindk_h1_mec_&aar2.=virtuelindk_h1_mec_&aar2.*inflation&aar2._2005;    *ditto. (2);*/
/*virtuelindk_h2_mec_&aar2.=virtuelindk_h2_mec_&aar2.*inflation&aar2._2005;    *ditto. (2);*/
virtuelindk_i_mec_&aar3.=virtuelindk_i_mec_&aar3.*inflation&aar3._2005;      *ditto. (3);
virtuelindk_h1_mec_&aar3.=virtuelindk_h1_mec_&aar3.*inflation&aar3._2005;    *ditto. (3);
virtuelindk_h2_mec_&aar3.=virtuelindk_h2_mec_&aar3.*inflation&aar3._2005;    *ditto. (3);

tax1_&aar.=tax1*inflation&aar._2005;
c_tax1_&aar.=c_tax1*inflation&aar._2005;

/*%if &aar. >= 1991 %then %do;*/
/*akt_&aar.=aktind*inflation&aar._2005;*/
/*c_akt_&aar.=c_aktind*inflation&aar._2005;*/
/*%end;*/
rename tau_arb_i=tau_arb_i&aar. 
       tau_apers_i=tau_apers_i&aar.
       tau_kap_i=tau_kap_i&aar.
	   tau_frad_i=tau_frad_i&aar.
	   tau_arb_h=tau_arb_h&aar. 
       tau_apers_h=tau_apers_h&aar.
       tau_kap_h=tau_kap_h&aar.
	   tau_frad_h=tau_frad_h&aar.
	   c_tau_arb_i=c_tau_arb_i&aar. 
       c_tau_apers_i=c_tau_apers_i&aar.
       c_tau_kap_i=c_tau_kap_i&aar.
	   c_tau_frad_i=c_tau_frad_i&aar.
	   c_tau_arb_h=c_tau_arb_h&aar. 
       c_tau_apers_h=c_tau_apers_h&aar.
       c_tau_kap_h=c_tau_kap_h&aar.
	   c_tau_frad_h=c_tau_frad_h&aar.
/*	   tau_arb_i_mec=tau_arb_i_mec&aar. */
/*       tau_apers_i_mec=tau_apers_i_mec&aar.*/
/*       tau_kap_i_mec=tau_kap_i_mec&aar.*/
/*	   tau_frad_i_mec=tau_frad_i_mec&aar.*/
/*	   tau_arb_h_mec=tau_arb_h_mec&aar. */
/*       tau_apers_h_mec=tau_apers_h_mec&aar.*/
/*       tau_kap_h_mec=tau_kap_h_mec&aar.*/
/*	   tau_frad_h_mec=tau_frad_h_mec&aar.*/
/*	   c_tau_arb_i_mec=c_tau_arb_i_mec&aar. */
/*       c_tau_apers_i_mec=c_tau_apers_i_mec&aar.*/
/*       c_tau_kap_i_mec=c_tau_kap_i_mec&aar.*/
/*	   c_tau_frad_i_mec=c_tau_frad_i_mec&aar.*/
/*	   c_tau_arb_h_mec=c_tau_arb_h_mec&aar. */
/*       c_tau_apers_h_mec=c_tau_apers_h_mec&aar.*/
/*       c_tau_kap_h_mec=c_tau_kap_h_mec&aar.*/
/*	   c_tau_frad_h_mec=c_tau_frad_h_mec&aar.*/
/*	   tau_akt_h=tau_akt_h&aar.*/
/*	   c_tau_akt_h=c_tau_akt_h&aar.*/
/*	   tau_akt_h_mec=tau_akt_h_mec&aar.*/
/*	   c_tau_akt_h_mec=c_tau_akt_h_mec&aar.*/
       ;
if a=1 and b=1;
run;

%end; *Slutningen på hele "if aar in (1989-2013)"-loopet, der indlæser (og nu merger) mechanical;


%if &aar >= 2014 %then %do; *Herfra henter vi ikke mekaniske ændringer ;
data ska&aar.;
merge marg.skat&aar.(in=a) ft.ind (keep=id_nr omfang in=b);
by id_nr;
if a=1 and b=1;
if omfang=1 then omfskpl=0; else omfskpl=1;
if kon=1 then mand=1; else mand=0;
drop kon;
run;

data k(keep=tiar inflation&aar._2005);
set div.inflation(where=(infl&aar._2005=1));
inflation&aar._2005=inflation;
run;


data skat&aar.(drop=per cap dec ear c_per c_cap c_dec c_ear per_income c_per_income  virtuelindk_i virtuelindk_h1
virtuelindk_h2 tax1 c_tax1) /*ud.skat&aar. var ned til kontrol*/;
merge ska&aar.(in=a) k(in=b);
by tiar;
if omfskpl=0 then spligt&aar.=1; else spligt&aar.=0;
per_&aar.=per*inflation&aar._2005;
cap_&aar.=cap*inflation&aar._2005;
dec_&aar.=dec*inflation&aar._2005;
ear_&aar.=ear*inflation&aar._2005;
c_per_&aar.=c_per*inflation&aar._2005;
c_cap_&aar.=c_cap*inflation&aar._2005;
c_dec_&aar.=c_dec*inflation&aar._2005;
c_ear_&aar.=c_ear*inflation&aar._2005;
per_income_&aar.=per_income*inflation&aar._2005;
c_per_income_&aar.=c_per_income*inflation&aar._2005;
virtuelindk_i_&aar.=virtuelindk_i*inflation&aar._2005;
virtuelindk_h1_&aar.=virtuelindk_h1*inflation&aar._2005;
virtuelindk_h2_&aar.=virtuelindk_h2*inflation&aar._2005;
tax1_&aar.=tax1*inflation&aar._2005;
c_tax1_&aar.=c_tax1*inflation&aar._2005;
/*akt_&aar.=aktind*inflation&aar._2005;*/
/*c_akt_&aar.=c_aktind*inflation&aar._2005;*/
rename tau_arb_i=tau_arb_i&aar. 
       tau_apers_i=tau_apers_i&aar.
       tau_kap_i=tau_kap_i&aar.
	   tau_frad_i=tau_frad_i&aar.
	   tau_arb_h=tau_arb_h&aar. 
       tau_apers_h=tau_apers_h&aar.
       tau_kap_h=tau_kap_h&aar.
	   tau_frad_h=tau_frad_h&aar.
	   c_tau_arb_i=c_tau_arb_i&aar. 
       c_tau_apers_i=c_tau_apers_i&aar.
       c_tau_kap_i=c_tau_kap_i&aar.
	   c_tau_frad_i=c_tau_frad_i&aar.
	   c_tau_arb_h=c_tau_arb_h&aar. 
       c_tau_apers_h=c_tau_apers_h&aar.
       c_tau_kap_h=c_tau_kap_h&aar.
	   c_tau_frad_h=c_tau_frad_h&aar.
/*	   tau_akt_h=tau_akt_h&aar.*/
/*	   c_tau_akt_h=c_tau_akt_h&aar.*/
	 
	   /*gift=gift&aar.*/;
	   if a=1 and b=1;
run;
%end;

proc datasets library=work; /*delete ska&aar. k inf&aar. inst_indkomst&aar. skat&aar3._indkomst&aar.*/; 
run;
 *Anluj: Behlder datasæt til at finde fejl; *ANLUJ2: Dropper igen, da vi har testet at fejlen ikke er dér;
%end;
%mend;
%step1;



* STEP 2: USING DATA FROM STEP 1, THIS STEP MERGES DATA FOR YEAR T WITH DATA FOR YEAR T+3 AND SELECT THE ESTIMATION SAMPLE ;

%macro step2;
%do aar=1989 %to 2013; *1989-2013 er alle år (se kommentar ved step1);

%let aar_2=%eval(&aar.-2); *Til -2års ændringer i marginalskat;
%let aar_1=%eval(&aar.-1); *Til -1års ændringer i marginalskat;
/*%let aar1=%eval(&aar.+1); *Til 1års ændringer i marginalskat;*/
/*%let aar2=%eval(&aar.+2); *Til 2års ændringer i marginalskat;*/
%let aar3=%eval(&aar.+3); *Til 3års ændringer i marginalskat;


*ANLUJ: Merger år -2 til 3 og beholder relevabte varuable. Kan eventuelt kodes uden loop - Det vil formentlig gå hurtigere, men koden vil fylde 5 gange så meget;
%do i=1 %to 3;
	%let list=&aar_2 &aar_1 /*&aar1 &aar2*/ &aar3;
	%let aarX=%scan(&list.,&i.);	
	%if &aarX. <= 2007 %then %do; %let STILLING=PSTILL; %end; 
	%if &aarX. >  2007 %then %do; %let STILLING=psoc_status_kode; %end; 

	data tmp&aarX.;	set skat&aarX. 
	(keep=id_nr per_&aarX. cap_&aarX. dec_&aarX. ear_&aarX. c_per_&aarX.
	tax1_&aarX. c_tax1_&aarX. /*tau_akt_h&aarX. c_tau_akt_h&aarX. */ per_income_&aarX. c_per_income_&aarX.
 	c_cap_&aarX. c_dec_&aarX. c_ear_&aarX. virtuelindk_i_&aarX. virtuelindk_h1_&aarX.
  	virtuelindk_h2_&aarX. spligt&aarX. tau_arb_i&aarX. tau_apers_i&aarX. tau_kap_i&aarX.
	tau_frad_i&aarX. tau_arb_h&aarX. tau_apers_h&aarX. tau_kap_h&aarX. tau_frad_h&aarX.
	c_tau_arb_i&aarX. c_tau_apers_i&aarX. c_tau_kap_i&aarX. c_tau_frad_i&aarX. /*%if &aar. >= 1993 %then %do; akt_&aarX. c_akt_&aarX. %end; */
	c_tau_arb_h&aarX. c_tau_apers_h&aarX. c_tau_kap_h&aarX. c_tau_frad_h&aarX. 
	alder &STILLING. rename=(alder=alder&aarX. &STILLING.=PSTILL&aarX.));
	run;
%end;

data tax&aar.(drop=spligt&aar. spligt&aar3. inflation&aar._2005 inflation&aar3._2005 omfskpl);
merge skat&aar. (in=a) tmp&aar_2. (in=b) tmp&aar_1. (in=c) /*tmp&aar1. (in=d) tmp&aar2. (in=e)*/ tmp&aar3. (in=f);
by id_nr;
if a and b and c /*and d and e */ and f;

occ=2; *lønmodtager som default;
if 11<=pstill<=20 then occ=1; *selvstændige;

*Definerer tomme variable til at gemme oplysninger om hvor folk smides ud;
slet1=0;
slet2=0;
slet3=0;

*Personer skal være i alderen &alder_keep år i år s;
if alder 	   not in &Alder_keep. then slet1=1;  

*Personer skal være fuldt ud skattepligtige i alle år;
if spligt&aar.=0 then slet2=1;  

*Personer, hvor alle marginalskater er nul, fjernes fra sample;
if tau_arb_i&aar.=0 and tau_apers_i&aar.=0 and tau_kap_i&aar.=0 and tau_frad_i&aar.=0
and tau_arb_h&aar.=0 and tau_apers_h&aar.=0 and tau_kap_h&aar.=0 and tau_frad_h&aar.=0 then slet3=1;

*Personer hvor mindst én skat er over 100 pct. fjernes fra sample;
if tau_arb_i&aar.>100 or tau_apers_i&aar.>100 or tau_kap_i&aar.>100 or tau_frad_i&aar.>100
or tau_arb_h&aar.>100 or tau_apers_h&aar.>100 or tau_kap_h&aar.>100 or tau_frad_h&aar.>100 then slet3=1;

*Personer, hvor alle virtuelindkomster er ikke positiv, fjernes fra sample;
if virtuelindk_i_&aar.<=0 and virtuelindk_h1_&aar.<=0 and virtuelindk_h2_&aar.<=0 then slet3=1;


*Restriktioner på indkomst og tax rates;

if tau_arb_i&aarX.=0 and tau_apers_i&aarX.=0 and tau_kap_i&aarX.=0 and tau_frad_i&aarX.=0
and tau_arb_h&aarX.=0 and tau_apers_h&aarX.=0 and tau_kap_h&aarX.=0 and tau_frad_h&aarX.=0 then slet3=1;
if tau_arb_i&aarX.>100 or tau_apers_i&aarX.>100 or tau_kap_i&aarX.>100 or tau_frad_i&aarX.>100
or tau_arb_h&aarX.>100 or tau_apers_h&aarX.>100 or tau_kap_h&aarX.>100 or tau_frad_h&aarX.>100 then slet3=1;
if virtuelindk_i_&aarX.<=0 and virtuelindk_h1_&aarX.<=0 and virtuelindk_h2_&aarX.<=0 then slet3=1;

*Samme restriktioner lægges på de øvrige år (-2 til +3) [også for instrumenterne i tilfælde af marginalskatter] MOAN: kører kun for instrumenterne; 
%do i=1 %to 3;
%let list=&aar_2 &aar_1 /*&aar1 &aar2*/ &aar;
%let aarX=%scan(&list., &i.); 
if alder/*&aarX.*/ not in &Alder_keep. then slet1=1; 
if spligt&aarX.=0 then slet2=1;

if tau_arb_i_mec_&aarX.=0 and tau_apers_i_mec_&aarX.=0 and tau_kap_i_mec_&aarX.=0 and tau_frad_i_mec_&aarX.=0
and tau_arb_h_mec_&aarX.=0 and tau_apers_h_mec_&aarX.=0 and tau_kap_h_mec_&aarX.=0 and tau_frad_h_mec_&aarX.=0 then Slet3=1;

if tau_arb_i_mec_&aarX.>100 or tau_apers_i_mec_&aarX.>100 or tau_kap_i_mec_&aarX.>100 or tau_frad_i_mec_&aarX.>100
or tau_arb_h_mec_&aarX.>100 or tau_apers_h_mec_&aarX.>100 or tau_kap_h_mec_&aarX.>100 or tau_frad_h_mec_&aarX.>100 then slet3=1;

if virtuelindk_i_mec_&aarX.<=0 and virtuelindk_h1_mec_&aarX.<=0 and virtuelindk_h2_mec_&aarX.<=0 then slet3=1;

%end;


%if &STILLING.=psoc_status_kode %then %do;
rename psoc_status_kode=PSTILL;
%end;

if sum(Slet1, slet2, slet3) >0 then delete; *ANLUJ: Kan slås fra til samplesize opgørelse senere;
run;


%end;
%mend;
%step2;

proc datasets lib=work nolist;
delete tmp:;
run;

****STEP 3: USING DATA FROM STEP 2, THIS STEP CONSTRUCTS INCOME AND TAX VARIABLES FOR ESTIMATION FOR EACH YEAR***;
%macro step3;
%do aar=1989 %to 2013;   *1989-2013 er alle år;

%let aar_2=%eval(&aar.-2); *Til -2års ændringer i marginalskat;
%let aar_1=%eval(&aar.-1); *Til -1års ændringer i marginalskat;
%let aar1=%eval(&aar.+1); *Til 1års ændringer i marginalskat;
%let aar2=%eval(&aar.+2); *Til 2års ændringer i marginalskat;
%let aar3=%eval(&aar.+3); *Til 3års ændringer i marginalskat;


%let list=&aar_2 &aar_1 /*&aar1 &aar2*/ &aar;
%let name= _2 _1 /*1 2*/ 0;
%do i=1 %to 3;
	%let aarX=%scan(&list.,&i.);
	%let navn=%scan(&name.,&i.);

	data tmp_&aarX.(drop=per_1: per_2: cap_: dec_: ear_: c_per_: tax1_: c_tax1_:  /*ANLUJ: hvis vi bare dropper per_: ryger per_income også - derfor den spøjse formulering*/
                c_cap_: c_dec_: c_ear_: virtuelindk_i_: 
                virtuelindk_h1_: virtuelindk_h2_: tau_arb_i:
                tau_apers_i: tau_kap_i: tau_frad_i: tau_arb_h: 
                tau_apers_h: tau_kap_h: tau_frad_h: c_tau_arb_i: 
                c_tau_apers_i: c_tau_kap_i: c_tau_frad_i: c_tau_arb_h:
                c_tau_apers_h: c_tau_kap_h: c_tau_frad_h:
                virtuelindk_i_mec: virtuelindk_h1_mec: virtuelindk_h2_mec: 
			    tau_arb_i_mec: 
                tau_apers_i_mec: tau_kap_i_mec: tau_frad_i_mec: tau_arb_h_mec: 
                tau_apers_h_mec: tau_kap_h_mec: tau_frad_h_mec: c_tau_arb_i_mec: 
                c_tau_apers_i_mec: c_tau_kap_i_mec: c_tau_frad_i_mec: c_tau_arb_h_mec:
                c_tau_apers_h_mec: c_tau_kap_h_mec: c_tau_frad_h_mec:
                netincome: c_netincome: 
/*tau_akt_h: c_tau_akt_h: tau_akt_h_mec: c_tau_akt_h_mec: */ );
set tax&aar.;

*Ændringer i indkomst;
if ear_&aar3. >0 and ear_&aar. >0 then diffarb&navn.=log(ear_&aar3.)-log(ear_&aar.); else diffarb&navn.=.;
if dec_&aar3. >0 and dec_&aar. >0 then difffrad&navn.=log(dec_&aar3.)-log(dec_&aar.); else difffrad&navn.=.;
if per_&aar3. >0 and per_&aar. >0 then diffapers&navn.=log(per_&aar3.)-log(per_&aar.); else diffapers&navn.=.;
if cap_&aar3. >0 and cap_&aar. >0 then diffkap&navn.=log(cap_&aar3.)-log(cap_&aar.); else diffkap&navn.=.;

*Beregner log-forskellen i net-of tax rate; 
if 0<tau_arb_i&aar.<1 and 0<tau_arb_i&aar3.<1 then diffMTR_arb_i&navn.=log((1-tau_arb_i&aar3.)/(1-tau_arb_i&aar.));
if 0<tau_apers_i&aar.<1 and 0<tau_apers_i&aar3.<1 then diffMTR_apers_i&navn.=log((1-tau_apers_i&aar3.)/(1-tau_apers_i&aar.));
if 0<tau_kap_i&aar.<1 and 0<tau_kap_i&aar3.<1 then diffMTR_kap_i&navn.=log((1-tau_kap_i&aar3.)/(1-tau_kap_i&aar.));
if 0<tau_frad_i&aar.<1 and 0<tau_frad_i&aar3.<1 then diffMTR_frad_i&navn.=log((1-tau_frad_i&aar3.)/(1-tau_frad_i&aar.));

if 0<tau_arb_h&aar.<1 and 0<tau_arb_h&aar3.<1 then diffMTR_arb_h&navn.=log((1-tau_arb_h&aar3.)/(1-tau_arb_h&aar.));
if 0<tau_apers_h&aar.<1 and 0<tau_apers_h&aar3.<1 then diffMTR_apers_h&navn.=log((1-tau_apers_h&aar3.)/(1-tau_apers_h&aar.));
if 0<tau_kap_h&aar.<1 and 0<tau_kap_h&aar3.<1 then diffMTR_kap_h&navn.=log((1-tau_kap_h&aar3.)/(1-tau_kap_h&aar.));
if 0<tau_frad_h&aar.<1 and 0<tau_frad_h&aar3.<1 then diffMTR_frad_h&navn.=log((1-tau_frad_h&aar3.)/(1-tau_frad_h&aar.));
*if 0<tau_akt_h&aar.<1 and 0<tau_akt_h&aar3.<1 then diffMTR_akt_h&navn.=log((1-tau_akt_h&aar3.)/(1-tau_akt_h&aar.));

if 0<c_tau_arb_i&aar.<1 and 0<c_tau_arb_i&aar3.<1 then c_diffMTR_arb_i&navn.=log((1-c_tau_arb_i&aar3.)/(1-c_tau_arb_i&aar.));
if 0<c_tau_apers_i&aar.<1 and 0<c_tau_apers_i&aar3.<1 then c_diffMTR_apers_i&navn.=log((1-c_tau_apers_i&aar3.)/(1-c_tau_apers_i&aar.));
if 0<c_tau_kap_i&aar.<1 and 0<c_tau_kap_i&aar3.<1 then c_diffMTR_kap_i&navn.=log((1-c_tau_kap_i&aar3.)/(1-c_tau_kap_i&aar.));
if 0<c_tau_frad_i&aar.<1 and 0<c_tau_frad_i&aar3.<1 then c_diffMTR_frad_i&navn.=log((1-c_tau_frad_i&aar3.)/(1-c_tau_frad_i&aar.));

if 0<c_tau_arb_h&aar.<1 and 0<c_tau_arb_h&aar3.<1 then c_diffMTR_arb_i&navn.=log((1-c_tau_arb_h&aar3.)/(1-c_tau_arb_h&aar.));
if 0<c_tau_apers_h&aar.<1 and 0<c_tau_apers_h&aar3.<1 then c_diffMTR_apers_i&navn.=log((1-c_tau_apers_h&aar3.)/(1-c_tau_apers_h&aar.));
if 0<c_tau_kap_h&aar.<1 and 0<c_tau_kap_h&aar3.<1 then c_diffMTR_kap_i&navn.=log((1-c_tau_kap_h&aar3.)/(1-c_tau_kap_h&aar.));
if 0<c_tau_frad_h&aar.<1 and 0<c_tau_frad_h&aar3.<1 then c_diffMTR_frad_i&navn.=log((1-c_tau_frad_h&aar3.)/(1-c_tau_frad_h&aar.));
*if 0<c_tau_akt_h&aar.<1 and 0<c_tau_akt_h&aar3.<1 then c_diffMTR_akt_i&navn.=log((1-c_tau_akt_h&aar3.)/(1-c_tau_akt_h&aar.));

*Beregner instrument for log-forskellen i net-of-tax rate;
if 0<tau_arb_i&aar.<1 and 0<tau_arb_i_mec_&aarX.<1 then diffMTR_arb_i_IV&navn.=log((1-tau_arb_i_mec_&aarX.)/(1-tau_arb_i&aar.));
if 0<tau_apers_i&aar.<1 and 0<tau_apers_i_mec_&aarX.<1 then diffMTR_apers_i_IV&navn.=log((1-tau_apers_i_mec_&aarX.)/(1-tau_apers_i&aar.));
if 0<tau_kap_i&aar.<1 and 0<tau_kap_i_mec_&aarX.<1 then diffMTR_kap_i_IV&navn.=log((1-tau_kap_i_mec_&aarX.)/(1-tau_kap_i&aar.));
if 0<tau_frad_i&aar.<1 and 0<tau_frad_i_mec_&aarX.<1 then diffMTR_frad_i_IV&navn.=log((1-tau_frad_i_mec_&aarX.)/(1-tau_frad_i&aar.));

if 0<tau_arb_h&aar.<1 and 0<tau_arb_h_mec_&aarX.<1 then diffMTR_arb_h_IV&navn.=log((1-tau_arb_h_mec_&aarX.)/(1-tau_arb_h&aar.));
if 0<tau_apers_h&aar.<1 and 0<tau_apers_h_mec_&aarX.<1 then diffMTR_apers_h_IV&navn.=log((1-tau_apers_h_mec_&aarX.)/(1-tau_apers_h&aar.));
if 0<tau_kap_h&aar.<1 and 0<tau_kap_h_mec_&aarX.<1 then diffMTR_kap_h_IV&navn.=log((1-tau_kap_h_mec_&aarX.)/(1-tau_kap_h&aar.));
if 0<tau_frad_h&aar.<1 and 0<tau_frad_h_mec_&aarX.<1 then diffMTR_frad_h_IV&navn.=log((1-tau_frad_h_mec_&aarX.)/(1-tau_frad_h&aar.));
*if 0<tau_akt_h&aar.<1 and 0<tau_akt_h_mec_&aarX.<1 then diffMTR_akt_h_IV&navn.=log((1-tau_akt_h_mec_&aarX.)/(1-tau_akt_h&aar.));

if 0<c_tau_arb_i&aar.<1 and 0<c_tau_arb_i_mec_&aarX.<1 then c_diffMTR_arb_i_IV&navn.=log((1-c_tau_arb_i_mec_&aarX.)/(1-c_tau_arb_i&aar.));
if 0<c_tau_apers_i&aar.<1 and 0<c_tau_apers_i_mec_&aarX.<1 then c_diffMTR_apers_i_IV&navn.=log((1-c_tau_apers_i_mec_&aarX.)/(1-c_tau_apers_i&aar.));
if 0<c_tau_kap_i&aar.<1 and 0<c_tau_kap_i_mec_&aarX.<1 then c_diffMTR_kap_i_IV&navn.=log((1-c_tau_kap_i_mec_&aarX.)/(1-c_tau_kap_i&aar.));
if 0<c_tau_frad_i&aar.<1 and 0<c_tau_frad_i_mec_&aarX.<1 then c_diffMTR_frad_i_IV&navn.=log((1-c_tau_frad_i_mec_&aarX.)/(1-c_tau_frad_i&aar.));

if 0<c_tau_arb_h&aar.<1 and 0<c_tau_arb_h_mec_&aarX.<1 then c_diffMTR_arb_h_IV&navn.=log((1-c_tau_arb_h_mec_&aarX.)/(1-c_tau_arb_h&aar.));
if 0<c_tau_apers_h&aar.<1 and 0<c_tau_apers_h_mec_&aarX.<1 then c_diffMTR_apers_h_IV&navn.=log((1-c_tau_apers_h_mec_&aarX.)/(1-c_tau_apers_h&aar.));
if 0<c_tau_kap_h&aar.<1 and 0<c_tau_kap_h_mec_&aarX.<1 then c_diffMTR_kap_h_IV&navn.=log((1-c_tau_kap_h_mec_&aarX.)/(1-c_tau_kap_h&aar.));
if 0<c_tau_frad_h&aar.<1 and 0<c_tau_frad_h_mec_&aarX.<1 then c_diffMTR_frad_h_IV&navn.=log((1-c_tau_frad_h_mec_&aarX.)/(1-c_tau_frad_h&aar.));
*if 0<c_tau_akt_h&aar.<1 and 0<c_tau_akt_h_mec_&aarX.<1 then c_diffMTR_akt_h_IV&navn.=log((1-c_tau_akt_h_mec_&aarX.)/(1-c_tau_akt_h&aar.));

/* Beregner log-forskellen i nettoindkomst */
taxable&aar.=ear_&aar.+per_&aar.+cap_&aar.-dec_&aar.;
taxable&aar3.=ear_&aar3.+per_&aar3.+cap_&aar3.-dec_&aar3.;
if taxable&aar.>0 and taxable&aar3.>0 then difftax&navn.=log(taxable&aar3.)-log(taxable&aar.);

broad&aar.=ear_&aar.+cap_&aar.;
broad&aar3.=ear_&aar3.+cap_&aar3.;
if broad&aar.>0 and broad&aar3.>0 then diffbroad&navn.=log(broad&aar3.)-log(broad&aar.);

taxable=taxable&aar.;
broad=broad&aar.;
if taxable >0 then logtaxable=log(taxable); else taxable=.;
if broad >0 then logbroad=log(broad); else broad=.;

netincome&aar.=ear_&aar.+per_&aar.+cap_&aar.-dec_&aar.-tax1_&aar.;
netincome&aar3.=ear_&aar3.+per_&aar3.+cap_&aar3.-dec_&aar3.-tax1_&aar3.;
c_netincome&aar.=c_ear_&aar.+c_per_&aar.+c_cap_&aar.-c_dec_&aar.-c_tax1_&aar.;
c_netincome&aar3.=c_ear_&aar3.+c_per_&aar3.+c_cap_&aar3.-c_dec_&aar3.-c_tax1_&aar3.;

if netincome&aar.>0 and netincome&aar3.>0 then diffinc&navn.=log(netincome&aar3.)-log(netincome&aar.);

if c_netincome&aar.>0 and c_netincome&aar3.>0 then c_diffinc&navn.=log(c_netincome&aar3.)-log(c_netincome&aar.);

/* Beregner log-forskellen i virtuel indkomst */
if virtuelindk_i_&aar.>0 and virtuelindk_i_&aar3.>0 then 
diffvir_i&navn.=log(virtuelindk_i_&aar3./virtuelindk_i_&aar.);
if virtuelindk_h1_&aar.>0 and virtuelindk_h1_&aar3.>0 then
diffvir_h1&navn.=log(virtuelindk_h1_&aar3./virtuelindk_h1_&aar.);
if virtuelindk_h2_&aar.>0 and virtuelindk_h2_&aar3.>0 then 
diffvir_h2&navn.=log(virtuelindk_h2_&aar3./virtuelindk_h2_&aar.);

/* Beregner instrument for log-forskellen i virtuel indkomst */
if virtuelindk_i_&aar.>0 and virtuelindk_i_mec_&aarX.>0 then 
diffvir_i_IV&navn.=log(virtuelindk_i_mec_&aarX./virtuelindk_i_&aar.);
if virtuelindk_h1_&aar.>0 and virtuelindk_h1_mec_&aarX.>0 then
diffvir_h1_IV&navn.=log(virtuelindk_h1_mec_&aarX./virtuelindk_h1_&aar.);
if virtuelindk_h2_&aar.>0 and virtuelindk_h2_mec_&aarX.>0 then 
diffvir_h2_IV&navn.=log(virtuelindk_h2_mec_&aarX./virtuelindk_h2_&aar.);

/* Tager log til indkomster */
if ear_&aar. >0 then logarb=log(ear_&aar.); else logarb=.;
if per_&aar. >0 then logapers=log(per_&aar.); else logapers=.;
if cap_&aar. >0 then logkap=log(cap_&aar.); else logkap=.;
if dec_&aar. >0 then logfrad=log(dec_&aar.); else logfrad=.;

/* Omdøber indkomster */
arb=ear_&aar.;
apers=per_&aar.;
kap=cap_&aar.;
frad=dec_&aar.;
tax=tax1_&aar.;
tau_arb_i_pre=tau_arb_i&aar.;
tau_arb_h_pre=tau_arb_h&aar.;
tau_arb_i_post=tau_arb_i&aar3.;
tau_arb_h_post=tau_arb_h&aar3.;
tau_arb_i_mec&navn.=tau_arb_i_mec_&aarX.;
tau_arb_h_mec&navn.=tau_arb_h_mec_&aarX.;

tau_kap_i_pre=tau_kap_i&aar.;
tau_kap_h_pre=tau_kap_h&aar.;
tau_kap_i_post=tau_kap_i&aarX.;
tau_kap_h_post=tau_kap_h&aar3.;
tau_kap_i_mec&navn.=tau_kap_i_mec_&aarX.;
tau_kap_h_mec&navn.=tau_kap_h_mec_&aarX.;

tau_frad_i_pre=tau_frad_i&aar.;
tau_frad_h_pre=tau_frad_h&aar.;
tau_frad_i_post=tau_frad_i&aar3.;
tau_frad_h_post=tau_frad_h&aar3.;
tau_frad_i_mec&navn.=tau_frad_i_mec_&aarX.;
tau_frad_h_mec&navn.=tau_frad_h_mec_&aarX.;

if per_income_&aar.>0 and per_income_&aar3.>0 then diffper_income=log(per_income_&aar3./per_income_&aar.); else diffper_income=.;
per_income=per_income_&aar.;
if per_income_&aar. >0 then logper_income=log(per_income_&aar.); else logper_income=.;
run;
%end;
data tax2_&aar.; merge tmp:;
by id_nr;
run;

proc datasets lib=work nolist;
delete tmp:;
run;

%end;
%mend;
%step3;



*** STEP 4: USING DATA FROM STEP 3 AND ADMINISTRATIVE DATA ON MUNUCIPALITY OF LIVING, THIS STEP MERGES YEARLY 
           DATASETS INTO ONE DATASET, ADD SOCIOECONOMIC CONTROLS AND CONSTRUCT INCOME CONTROLS **** ;

*Laver kommuner til amter og sikrer at kom er en numerisk-variabel i alle år;
* Merger også brancheoplysninger på;
%macro step4a;
%do aar=1989 %to 2013; *1989-2013 er alle år;
libname FT "X:\MB\Fuldtællinger\&aar.." access=readonly;

%if &aar. < 1993 %then %do;
data tak&aar. (drop= KOM2 branche_77);
Merge tax2_&aar (rename=(KOM=KOM2) in=a) ft.indh (keep=id_nr branche_77);
by id_nr;
if a;

pdb932=branche_77;

kom=KOM2+0; *Laver kom nummerisk;

if 100<=kom<=147 then amt=1;
if 151<=kom<=189 then amt=2;
if 201<=kom<=237 then amt=3;
if 251<=kom<=271 then amt=4;
if 301<=kom<=345 then amt=5;
if 351<=kom<=397 then amt=6;
if 400<=kom<=411 then amt=7;
if 421<=kom<=499 then amt=8;
if 501<=kom<=545 then amt=9;
if 551<=kom<=577 then amt=10;
if 601<=kom<=631 then amt=11;
if 651<=kom<=685 then amt=12;
if 701<=kom<=751 then amt=13;
if 761<=kom<=793 then amt=14;
if 801<=kom<=861 then amt=15;
if 000<=kom<=019 or 996<=kom<=999 then amt=16;
if 931<=kom<=963 then amt=17;
run;
%end;



%if &aar. >= 1993 %then %do;
data tak&aar. (drop= KOM2 branche_kode);
Merge tax2_&aar (rename=(KOM=KOM2) in=a) 
	%if &aar. < 2007 %then %do; ft.RAS (keep=id_nr branche_kode); %end;
	%if &aar. >=2007 %then %do; ft.RAS (keep=id_nr ARB_HOVED_BRA_DB07 rename=(ARB_HOVED_BRA_DB07=Branche_kode)); %end;
by id_nr;
if a;

kom=KOM2+0; *laver kom nummerisk;

if 011110 <= branche_kode <= 020200 then pdb932=11100; *Skov, landbrug, fødevare;
if 102000 <= branche_kode <= 145000 then pdb932=21000; *Råstof;
if 151110 <= branche_kode <= 379900 then pdb932=31100; *Fremstilling/industri;
if 401000 <= branche_kode <= 410000 then pdb932=41000; *Forsyning;
if 451100 <= branche_kode <= 459900 then pdb932=50100; *bygge og anlæg;
if 501000 <= branche_kode <= 559900 then pdb932=61100; *Handel, restauration, hotel;
if 601000 <= branche_kode <= 649900 then pdb932=71100; *Transport mm.;
if 651000 <= branche_kode <= 749900 then pdb932=81000; *Finansiel, udlejning mm.;
if 751000 <= branche_kode <= 990000 then pdb932=91000; *Offentlig og tjenesteydelser;

if branche_kode in(524880,050100:050300,152010) 												then pdb932=11100; *Skov, landbrug, fødevare;
if branche_kode in(742060,262890)																then pdb932=21000; *Råstof;
if branche_kode in(101000,102000,725000, 527210,454410) 										then pdb932=31100; *Fremstilling/industri;
if branche_kode in(371000,372000,748490,714090,711000,714010) 									then pdb932=61100; *Handel, restauration, hotel;
if branche_kode in(71100:719900)																then pdb932=71100; *Transport mm;
if branche_kode in(753000,980000,924000) 														then pdb932=81000; *Finansiel, udlejning mm.;
if branche_kode in(745010,747010:747050,731000,732000,331090,702010,703220,223200,642000,223100,
				   748490,714090,527100,453100,527220,502010:502060,504000,502090,335000,527410,
				   527420,527490,748110,748120,714090) 											then pdb932=91000; *Offentlig og tjenesteydelser;


if 100<=kom<=147 then amt=1;
if 151<=kom<=189 then amt=2;
if 201<=kom<=237 then amt=3;
if 251<=kom<=271 then amt=4;
if 301<=kom<=345 then amt=5;
if 351<=kom<=397 then amt=6;
if 400<=kom<=411 then amt=7;
if 421<=kom<=499 then amt=8;
if 501<=kom<=545 then amt=9;
if 551<=kom<=577 then amt=10;
if 601<=kom<=631 then amt=11;
if 651<=kom<=685 then amt=12;
if 701<=kom<=751 then amt=13;
if 761<=kom<=793 then amt=14;
if 801<=kom<=861 then amt=15;
if 000<=kom<=019 or 996<=kom<=999 then amt=16;
if 931<=kom<=963 then amt=17;
%if &aar=2000 %then %do;
drop HFAUDD;
%end;
run;
%end;


%end;
%mend;
%step4a;

*Laver lokal arbejdsløshed (obs: K&S hentede det bare fra et prekonstrueret program;
*Merger også uddannelsesoplysningD:\projekt\Skatteelasticiteter\Programmerer på og kategorisere i 5 standardgrupper;
%macro step4b;
%do aar=1989 %to 2013; *1984-2013 er alle år;
libname FT "X:\MB\Fuldtællinger\&aar.." access=readonly;

%if &aar. <= 2007 %then %do;
data tmp; merge tak&aar. (keep=id_nr in=a) ft.IDAP(keep=ARLEDGR id_nr) ft.udda (keep= id_nr HFAUDD);
by id_nr;
if a;
if ^last.id_nr then delete;
if HFAUDD=. then HFAUDD=9999;
run;
%end;

%if &aar. >= 2008 %then %do;
data tmp; merge tak&aar. (keep=id_nr in=a) ft.IDAP(keep=ARLEDGR_brutto id_nr) ft.udda (keep= id_nr HFAUDD);
by id_nr;
if a;
if ^last.id_nr then delete;
if HFAUDD=. then HFAUDD=9999;
rename ARLEDGR_brutto=ARLEDGR; *ANLUJ: Renamer så vi bruger samme navn;
run;
%end;

proc sql; create table skat2&aar. as
select distinct a.*, mean(b.ARLEDGR/1000) as lokal_unemp, put(put(b.HFAUDD,AUDD_HOVED_L1L5_KT.),$AUDD5stdtest.) as HFAUDD
from tak&aar. as a 
left join tmp as b
on a.id_nr=b.id_nr
group by amt
order by id_nr;
quit;

%end;
%mend;
%step4b;


proc datasets library=work; delete tax2_1987-tax2_2013 tak1987-tak2013 skat1989-skat2016
tax1987-tax2013 ska2002 skat2005_indkomst2002 unemp tmp; 
run;

 data tax1989_2013_pre;
 set skat21989-skat22013; 
/* set skat 21984 skat21985 skat21986 skat21987 skat21988 skat21989 skat21990 skat21991*/
/* skat21992 skat21993 skat21994 skat21995 skat21996 skat21997 skat21998 skat21999*/
/* skat22000 skat22001 skat22002;*/
run;


proc datasets library=work; delete skat21984-skat22016; 
run;


*****Henter de sidste oplysninger fra BEF (som er lavet i vores baggrundsvariableprogram)******;
data tax1989_2013; merge tax1989_2013_pre (in=a) div.baggrundsvariable (keep= id_nr BØRN CIVST Etni tiar in=b);
by tiar id_nr;
if a;
run;
***********************************************************************************************;

proc sort data=tax1989_2013 nodupkey;
by tiar id_nr;
run;


data ud.tax1989_2013(drop=pdb932);
set tax1989_2013(drop= /*akt_1991-akt_2016 c_akt_1991-c_akt_2016*/); 

 
/*if kon=1 then mand=1; else mand=0;*/

*Dette har jeg ikke lavet. Vores civilstand har umiddelbart ikke nogen måde at skelne mellem ugift og single. Kan nok fikses hvis det bliver relevant;
/**kvindegrupper;*/
/*if kon=0 then kvinde=1; else kvinde=0;*/
/*if kon=0 and cstatus=1 and anc017>0 then enligkvindeborn=1; else enligkvindeborn=0;*/
/*if cstatus=2 then giftkvinde=1; else giftkvinde=0;*/

if HFAUDD = "Ufaglært"  then Udd1=1; else udd1=0;
if HFAUDD = "Faglærte"  then Udd2=1; else udd2=0;
if HFAUDD = "KVU" 		then Udd3=1; else udd3=0;
if HFAUDD = "MVU" 		then Udd4=1; else udd4=0;
if HFAUDD = "LVU" 		then Udd5=1; else udd5=0;
if HFAUDD = "Uoplyst"   then Udd0=1; else udd0=0;
If udd1=udd2=udd3=udd4=udd5=0 then udd0=1;

/*
if 90309910<=hfaudd<=90309920 then udd1=1; else udd1=0; *Uoplyst;
if 10000000<=hfaudd<=30999999 then udd2=1; else udd2=0; *Ufaglært;
if 35000000<=hfaudd<=35999999 then udd3=1; else udd3=0; *Faglært;
if 40000000<=hfaudd<=40999999 then udd4=1; else udd4=0; *KVU?;
if 50000000<=hfaudd<=50999999 then udd5=1; else udd5=0; *MVU;
if 60000000<=hfaudd<=70999999 then udd6=1; else udd6=0; *LVU;
if udd1=0 and udd2=0 and udd3=0 and udd4=0 and udd5=0 and udd6=0 then udd1=1;

if 011110<=pdb932<=145000 then ind1=1; else ind1=0;
if 151110<=pdb932<=372000 then ind2=1; else ind2=0;
if 401100<=pdb932<=410000 then ind3=1; else ind3=0;
if 451100<=pdb932<=455000 then ind4=1; else ind4=0;
if 501010<=pdb932<=555200 then ind5=1; else ind5=0;
if 601000<=pdb932<=642040 or pdb932=926220 then ind6=1; else ind6=0;
if 651100<=pdb932<=748790 then ind7=1; else ind7=0;
if 751100<=pdb932<=926210 or 926290<=pdb932<=950000 or pdb932=990000 then ind8=1; else ind8=0;
if pdb932=980000 then ind9=1; else ind9=0;
if ind1=0 and ind2=0 and ind3=0 and ind4=0 and ind5=0 and ind6=0 and ind7=0
and ind8=0 and ind9=0 then ind9=1;
*/

if 11100 <= pdb932 <= 13029 then ind1=1; else ind1=0; *Skov, landbrug, fødevare;
if 21000 <= pdb932 <= 29090 then ind2=1; else ind2=0; *Råstof;
if 31100 <= pdb932 <= 39099 then ind3=1; else ind3=0; *Fremstilling/industri;
if 41000 <= pdb932 <= 42000 then ind4=1; else ind4=0; *Forsyning;
if 50100 <= pdb932 <= 50199 then ind5=1; else ind5=0; *bygge og anlæg;
if 61100 <= pdb932 <= 63209 then ind6=1; else ind6=0; *Handel, restauration, hotel;
if 71100 <= pdb932 <= 72002 then ind7=1; else ind7=0; *Transport mm.;
if 81000 <= pdb932 <= 83329 then ind8=1; else ind8=0; *Finansiel, udlejning mm.;
if 91000 <= pdb932 <= 96002 then ind9=1; else ind9=0; *Offentlig og tjenesteydelser;
if ind1=ind2=ind3=ind4=ind5=ind6=ind7=ind8=ind9=0 then ind0=1; else ind0=0;


*BNP-vækst;
*ANLUJ: Hentet fra DST: NAN1 (realvækst i BNP [regnet selv via udskrift i faste priser for at få ekstra decimal]). Har overskrevet de værdier K&S havde indtastet;
if tiar=1984 then gdp=4.17;
if tiar=1985 then gdp=4.00;
if tiar=1986 then gdp=4.90;
if tiar=1987 then gdp=0.25;
if tiar=1988 then gdp=-0.01;
if tiar=1989 then gdp=0.65;
if tiar=1990 then gdp=1.48;
if tiar=1991 then gdp=1.39;
if tiar=1992 then gdp=1.96;
if tiar=1993 then gdp=0.01;
if tiar=1994 then gdp=5.33;
if tiar=1995 then gdp=3.03;
if tiar=1996 then gdp=2.90;
if tiar=1997 then gdp=3.26;
if tiar=1998 then gdp=2.22;
if tiar=1999 then gdp=2.95;
if tiar=2000 then gdp=3.75;
if tiar=2001 then gdp=0.82;
if tiar=2002 then gdp=0.47;
if tiar=2003 then gdp=0.39;
if tiar=2004 then gdp=2.67;
if tiar=2005 then gdp=2.34;
if tiar=2006 then gdp=3.91;
if tiar=2007 then gdp=0.91;
if tiar=2008 then gdp=-0.51;
if tiar=2009 then gdp=-4.91;
if tiar=2010 then gdp=1.87;
if tiar=2011 then gdp=1.34;
if tiar=2012 then gdp=0.23;
if tiar=2013 then gdp=0.93;

*Bunching ;
if -2000<=bkink<=2000 then bk=1; else bk=0;
if -2000<=mkink<=2000 then mk=1; else mk=0; if -3000<=mkink<=3000 then mk_3000=1; else mk_3000=0; 
if -2000<=tkink<=2000 then tk=1; else tk=0; if -5000<=tkink<=5000 then tk_5000=1; else tk_5000=0;  
kink=bk+mk+tk;
/*if kink ne 0 then delete;*/

/*oprindelsesland*/
/*
nonoecd=1;
if ieland in(5104,5106,5108,5110,5120,5126,5130,5134,5140,5142,5150,5154,5156,5160,5164,
             5170,5172,5174,5182,5184,5314,5354,5390,5444,5466,5502,5514,5776,5778) 
then nonoecd=0;
*/
/* immigrantstatus */
/*immigrant=1;
if ietype=1 then immigrant=0;
*/
/* beskæftigelsesstatus*//*
occ=4;
if 11<=pstill<=20 then occ=1;
if 31<=pstill<=37 then occ=2;
if pstill=40 then occ=3;*/

if tiar=1984 then a=1; 
if tiar=1985 then a=2; 
if tiar=1986 then a=3;
if tiar=1987 then a=4; 
if tiar=1988 then a=5; 
if tiar=1989 then a=6;
if tiar=1990 then a=7;
if tiar=1991 then a=8;
if tiar=1992 then a=9;  
if tiar=1993 then a=10;  
if tiar=1994 then a=11;  
if tiar=1995 then a=12;
if tiar=1996 then a=13;  
if tiar=1997 then a=14;  
if tiar=1998 then a=15; 
if tiar=1999 then a=16;
if tiar=2000 then a=17;
if tiar=2001 then a=18;
if tiar=2002 then a=19; 
if tiar=2003 then a=20; 
if tiar=2004 then a=21; 
if tiar=2005 then a=22; 
if tiar=2006 then a=23; 
if tiar=2007 then a=24; 
if tiar=2008 then a=25; 
if tiar=2009 then a=26; 
if tiar=2010 then a=27; 
if tiar=2011 then a=28; 
if tiar=2012 then a=29; 
if tiar=2013 then a=30; 

if a=1 then d84=1; else d84=0;
if a=2 then d85=1; else d85=0;
if a=3 then d86=1; else d86=0;
if a=4 then d87=1; else d87=0;
if a=5 then d88=1; else d88=0;
if a=6 then d89=1; else d89=0;
if a=7 then d90=1; else d90=0;
if a=8 then d91=1; else d91=0;
if a=9 then d92=1; else d92=0;
if a=10 then d93=1; else d93=0;
if a=11 then d94=1; else d94=0;
if a=12 then d95=1; else d95=0;
if a=13 then d96=1; else d96=0;
if a=14 then d97=1; else d97=0;
if a=15 then d98=1; else d98=0;
if a=16 then d99=1; else d99=0;
if a=17 then d00=1; else d00=0;
if a=18 then d01=1; else d01=0;
if a=19 then d02=1; else d02=0;
if a=20 then d03=1; else d03=0;
if a=21 then d04=1; else d04=0;
if a=22 then d05=1; else d05=0;
if a=23 then d06=1; else d06=0;
if a=24 then d07=1; else d07=0;
if a=25 then d08=1; else d08=0;
if a=26 then d09=1; else d09=0;
if a=27 then d10=1; else d10=0;
if a=28 then d11=1; else d11=0;
if a=29 then d12=1; else d12=0;
if a=30 then d13=1; else d13=0;



if amt=1 then amt1=1; else amt1=0;
if amt=2 then amt2=1; else amt2=0;
if amt=3 then amt3=1; else amt3=0;
if amt=4 then amt4=1; else amt4=0;
if amt=5 then amt5=1; else amt5=0;
if amt=6 then amt6=1; else amt6=0;
if amt=7 then amt7=1; else amt7=0;
if amt=8 then amt8=1; else amt8=0;
if amt=9 then amt9=1; else amt9=0;
if amt=10 then amt10=1; else amt10=0;
if amt=11 then amt11=1; else amt11=0;
if amt=12 then amt12=1; else amt12=0;
if amt=13 then amt13=1; else amt13=0;
if amt=14 then amt14=1; else amt14=0;
if amt=15 then amt15=1; else amt15=0;

run;

proc sort data=ud.tax1989_2013; by id_nr tiar; run;


%macro kontrol;
%do aar=1987 %to 1988;
Data indkomst&aar. (keep=id_nr tiar apers arb kap frad logper_income per_income 
logapers logarb logkap logfrad taxable logtaxable broad logbroad); SET SKAT&aar.;
by tiar;

arb=ear_&aar.;
apers=per_&aar.;
kap=cap_&aar.;
frad=dec_&aar.;

broad=arb+kap;
taxable=arb+apers+kap-frad;

per_income=arb+apers;

if apers>0 then logapers=log(apers); else logapers=.;
if arb>0 then logarb=log(arb); else logarb=.;
if kap>0 then logkap=log(kap); else logkap=.;
if frad>0 then logfrad=log(frad); else logfrad=.;
if per_income>0 then logper_income=log(per_income); else logper_income=.;
if broad>0 then logbroad=log(broad); else logbroad=.;
if taxable>0 then logtaxable=log(taxable); else logtaxable=.;
run;
%end;
%mend;
%kontrol;




Data k;
set indkomst1987 indkomst1988 ud.tax1989_2013(keep=id_nr tiar logarb logapers 
logkap logfrad arb apers kap frad per_income /*logper_income*/ logtaxable taxable logbroad broad);
run;

proc sort data=k; by id_nr tiar; run;

data controls;
set k;

arb2=arb;
apers2=apers;
kap2=kap;
frad2=frad;
per_income2=per_income;

if arb2 > 0 then logarb2=log(arb2);
if apers2 > 0 then logapers2=log(apers2);
if per_income2 > 0 then logper_income2=log(per_income2);
if kap2 > 0 then logkap2=log(kap2);
if frad2 > 0 then logfrad2=log(frad2);

lag2id_nr=lag(id_nr);
lag2tiar=lag(tiar);

parb2=lag(arb2);
if id_nr ne lag(id_nr) then parb2=.;
if tiar ne lag(tiar)+1 then parb2=.;
if parb2>0 then plogarb2=log(parb2);
if parb2>0 and arb2>0 then dlogarb2=logarb2-plogarb2;

p2arb2=lag(parb2);
if id_nr ne lag(lag2id_nr) then p2arb2=.;
if tiar ne lag(lag2tiar)+2 then p2arb2=.;
if p2arb2>0 then p2logarb2=log(p2arb2);
if p2arb2>0 and parb2 >0 then d2logarb2=plogarb2-p2logarb2;

papers2=lag(apers2);
if id_nr ne lag(id_nr) then papers2=.;
if tiar ne lag(tiar)+1 then papers2=.;
if papers2>0 then plogapers2=log(papers2);
if papers2>0 and apers2 >0 then dlogapers2=logapers2-plogapers2;

p2apers2=lag(papers2);
if id_nr ne lag(lag2id_nr) then p2apers2=.;
if tiar ne lag(lag2tiar)+2 then p2apers2=.;
if p2apers2>0 then p2logapers2=log(p2apers2);
if p2apers2>0 and papers2 >0 then d2logapers2=plogapers2-p2logapers2;

pper_income2=lag(per_income2);
if id_nr ne lag(id_nr) then pper_income2=.;
if tiar ne lag(tiar)+1 then pper_income2=.;
if pper_income2>0 then plogper_income2=log(pper_income2);
if pper_income2>0 and per_income2 >0 then dlogper_income2=logper_income2-plogper_income2;

p2per_income2=lag(pper_income2);
if id_nr ne lag(lag2id_nr) then p2per_income2=.;
if tiar ne lag(lag2tiar)+2 then p2per_income2=.;
if p2per_income2>0 then p2logper_income2=log(p2per_income2);
if p2per_income2>0 and pper_income2 >0 then d2logper_income2=plogper_income2-p2logper_income2;

pkap2=lag(kap2);
if id_nr ne lag(id_nr) then pkap2=.;
if tiar ne lag(tiar)+1 then pkap2=.;
if pkap2>0 then plogkap2=log(pkap2);
if pkap2>0 and kap2>0 then dlogkap2=logkap2-plogkap2;

p2kap2=lag(pkap2);
if id_nr ne lag(lag2id_nr) then p2kap2=.;
if tiar ne lag(lag2tiar)+2 then p2kap2=.;
if p2kap2>0 then p2logkap2=log(p2kap2);
if p2kap2>0 and pkap2>0 then d2logkap2=plogkap2-p2logkap2;

pfrad2=lag(frad2);
if id_nr ne lag(id_nr) then pfrad2=.;
if tiar ne lag(tiar)+1 then pfrad2=.;
if pfrad2>0 then plogfrad2=log(pfrad2);
if pfrad2>0 and frad2 >0 then dlogfrad2=logfrad2-plogfrad2;

p2frad2=lag(pfrad2);
if id_nr ne lag(lag2id_nr) then p2frad2=.;
if tiar ne lag(lag2tiar)+2 then p2frad2=.;
if p2frad2>0 then p2logfrad2=log(p2frad2);
if p2frad2>0 and pfrad2 >0 then d2logfrad2=plogfrad2-p2logfrad2;

taxable2=taxable;
if taxable2 > 0 then logtaxable2=log(taxable2);

ptaxable2=lag(taxable2);
if id_nr ne lag(id_nr) then ptaxable2=.;
if tiar ne lag(tiar)+1 then ptaxable2=.;
if ptaxable2>0 then plogtaxable2=log(ptaxable2);
if ptaxable2>0 and taxable2>0 then dlogtaxable2=logtaxable2-plogtaxable2;

p2taxable2=lag(ptaxable2);
if id_nr ne lag(lag2id_nr) then p2taxable2=.;
if tiar ne lag(lag2tiar)+2 then p2taxable2=.;
if p2taxable2>0 then p2logtaxable2=log(p2taxable2);
if p2taxable2>0 and ptaxable2>0 then d2logtaxable2=plogtaxable2-p2logtaxable2;

broad2=broad;
if broad2 > 0 then logbroad2=log(broad2);

pbroad2=lag(broad2);
if id_nr ne lag(id_nr) then pbroad2=.;
if tiar ne lag(tiar)+1 then pbroad2=.;
if pbroad2>0 then plogbroad2=log(pbroad2);
if pbroad2>0 and broad2>0 then dlogbroad2=logbroad2-plogbroad2;

p2broad2=lag(pbroad2);
if id_nr ne lag(lag2id_nr) then p2broad2=.;
if tiar ne lag(lag2tiar)+2 then p2broad2=.;
if p2broad2>0 then p2logbroad2=log(p2broad2);
if p2broad2>0 and pbroad2>0 then d2logbroad2=plogbroad2-p2logbroad2;


if id_nr = lag(id_nr) and tiar=lag(tiar)+1 then do;
parb=lag(arb);
papers=lag(apers);
pper_income=lag(per_income);
pkap=lag(kap);
pfrad=lag(frad);
ptaxable=lag(taxable);
pbroad=lag(broad);
end;
else do;
parb=.;
papers=.;
pper_income=.;
pkap=.;
pfrad=.;
ptaxable=.;
pbroad=.;
end;
if id_nr = lag(lag(id_nr)) and tiar=lag(lag(tiar))+2 then do;
p2arb=lag(parb);
p2apers=lag(papers);
p2per_income=lag(pper_income);
p2kap=lag(pkap);
p2frad=lag(pfrad);
p2taxable=lag(ptaxable);
p2broad=lag(pbroad);
end;
else do;
p2arb=.;
p2apers=.;
p2per_income=.;
p2kap=.;
p2frad=.;
p2taxable=.;
p2broad=.;
end;
run;
 

proc sort data=controls; by id_nr tiar; run;

*ANLUJ: Kodet op så merget sker 5 gange - det kan helt sikkert gøres meget hurtigere. Det kan sådan set bare skrives ud 
        så hver variable ikke må være missing. Det vil bare gøre koden meget længere at læse. Et array er måske svaret;
%macro samle; 
%let name= _2 _1 /*1 2 */0;
%do i=1 %to 3;
	%let navn=%scan(&name.,&i.);

data samle_tmp&navn.;
merge controls(drop=lag2tiar lag2id_nr)
ud.tax1989_2013(drop=per_income logper_income arb apers kap frad logarb logapers logkap logfrad logbroad logtaxable taxable broad in=b);
by id_nr tiar;

if arb ne . and parb2 ne . and p2arb2 ne . and logarb ne . and plogarb2 ne . and p2logarb2 ne .
and dlogarb2 ne . and d2logarb2 ne .
and diffarb&navn. ne . and diffMTR_arb_i&navn. ne . and diffMTR_arb_i_iV&navn. ne . and diffMTR_arb_h&navn. ne .
and diffMTR_arb_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and
diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . 
then arbstatus=1; else arbstatus=0; 

if arb ne . and parb2 ne .				   and logarb ne . 
and dlogarb2 ne .
and diffarb&navn. ne . and diffMTR_arb_i&navn. ne . and diffMTR_arb_i_iV&navn. ne . and diffMTR_arb_h&navn. ne .
and diffMTR_arb_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and
diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . 
then arbstatus2=1; else arbstatus2=0; 

if apers ne . and papers2 ne . and p2apers2 ne . and logapers ne . and plogapers2 ne . 
and p2logapers2 ne . and dlogapers2 ne . and d2logapers2 ne .
and diffapers&navn. ne . and diffMTR_apers_i&navn. ne . and diffMTR_apers_i_iV&navn. ne . and diffMTR_apers_h&navn. ne .
and diffMTR_apers_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and
diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . 
then apersstatus=1; else apersstatus=0;

if apers ne . and papers2 ne . and logapers ne . and dlogapers2 ne .  
and diffapers&navn. ne . and diffMTR_apers_i&navn. ne . and diffMTR_apers_i_iV&navn. ne . and diffMTR_apers_h&navn. ne .
and diffMTR_apers_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and
diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . 
then apersstatus2=1; else apersstatus2=0;

*ANLUJ: Dropper indtil videre reference til personlig indkomst (som alligevel ikke bliver brugt), da det er kodet forkert tidligere (step 3 tror jeg);
/*if per_income ne . and pper_income2 ne . and p2per_income2 ne . and logper_income ne . and plogper_income2 ne . and p2logper_income2 ne .*/
/*and dlogper_income2 ne . and d2logper_income2 ne .*/
/*and diffper_income&navn. ne . and diffMTR_arb_i&navn. ne . and diffMTR_arb_i_iV&navn. ne . and diffMTR_arb_h&navn. ne .*/
/*and diffMTR_arb_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and*/
/*diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . */
/*then per_incomestatus=1; else per_incomestatus=0; */
/**/
/*if per_income ne . and pper_income2 ne . and logper_income ne . and dlogper_income2 ne .*/
/*and diffper_income&navn. ne . and diffMTR_arb_i&navn. ne . and diffMTR_arb_i_iV&navn. ne . and diffMTR_arb_h&navn. ne .*/
/*and diffMTR_arb_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and*/
/*diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . */
/*then per_incomestatus2=1; else per_incomestatus2=0; */

if kap ne . and pkap2 ne . and p2kap2 ne . and logkap ne . and plogkap2 ne . and p2logkap2 ne .
and dlogkap2 ne . and d2logkap2 ne .
and diffkap&navn. ne . and diffMTR_kap_i&navn. ne . and diffMTR_kap_i_iV&navn. ne . and diffMTR_kap_h&navn. ne .
and diffMTR_kap_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and
diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . 
then kapstatus=1; else kapstatus=0;


if kap ne . and pkap2 ne . and logkap ne . and dlogkap2 ne .
and diffkap&navn. ne . and diffMTR_kap_i&navn. ne . and diffMTR_kap_i_iV&navn. ne . and diffMTR_kap_h&navn. ne .
and diffMTR_kap_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and
diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . 
then kapstatus2=1; else kapstatus2=0;

if frad ne . and pfrad2 ne . and p2frad2 ne . and logfrad ne . and plogfrad2 ne . and 
p2logfrad2 ne . and dlogfrad2 ne . and d2logfrad2 ne .
and difffrad&navn. ne . and diffMTR_frad_i&navn. ne . and diffMTR_frad_i_iV&navn. ne . and diffMTR_frad_h&navn. ne .
and diffMTR_frad_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and
diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . 
then fradstatus=1; else fradstatus=0;

if frad ne . and pfrad2 ne . and logfrad ne . 
and difffrad&navn. ne . and diffMTR_frad_i&navn. ne . and diffMTR_frad_i_iV&navn. ne . and diffMTR_frad_h&navn. ne .
and diffMTR_frad_h_iV&navn. ne . and diffvir_i&navn. ne . and diffvir_h1&navn. ne . and
diffvir_h2&navn. ne . and diffvir_i_iV&navn. ne . and diffvir_h1_iV&navn. ne . and diffvir_h2_iV&navn. ne . 
then fradstatus2=1; else fradstatus2=0;

count=arbstatus+kapstatus+fradstatus;
if count<1 then delete;
indkomst=arb+apers+kap;

if b=1;
rename børn=born lokal_unemp=unem difftax&navn.=difftaxable&navn.;
exp2=exp*exp;
run;
%end;
%mend;
%samle;

data samle2; merge samle_tmp:;
by id_nr tiar;
run;
proc datasets lib=work nolist;
delete samle_tmp:;
run;

proc sort data=samle2 out=ud.tax89_13_FuldModel_&date.;
by tiar; 
run;

%include "D:\OIM\mora\Genestimation\Programmer\Merge\Overforsel1984-2016 - 010219 mora.sas";


*ANLUJ: Slår alt det der 20-procents-inddeling fra; 


/*proc univariate data=samle2(where=(arbstatus=1) keep=indkomst arbstatus tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_arbstatus pctlpts=20 40 60 80 90 pctlpre=arbstatus_;*/
/*run;*/
/**/
/**/
/*proc univariate data=samle2(where=(arbstatus2=1) keep=indkomst arbstatus2 tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_arbstatus2 pctlpts=20 40 60 80 pctlpre=arbstatus2_;*/
/*run;*/
/**/
/**/
/*proc univariate data=samle2(where=(per_incomestatus=1) keep=indkomst per_incomestatus tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_per_incomestatus pctlpts=20 40 60 80 pctlpre=per_incomestatus_;*/
/*run;*/
/**/
/**/
/*proc univariate data=samle2(where=(per_incomestatus2=1) keep=indkomst per_incomestatus2 tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_per_incomestatus2 pctlpts=20 40 60 80 pctlpre=per_incomestatus2_;*/
/*run;*/
/**/
/**/
/**/
/*proc univariate data=samle2(where=(apersstatus=1) keep=indkomst apersstatus tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_apersstatus pctlpts=20 40 60 80 pctlpre=apersstatus_;*/
/*run;*/
/**/
/**/
/*proc univariate data=samle2(where=(apersstatus2=1) keep=indkomst apersstatus2 tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_apersstatus2 pctlpts=20 40 60 80 pctlpre=apersstatus2_;*/
/*run;*/
/**/
/**/
/*proc univariate data=samle2(where=(kapstatus=1) keep=indkomst kapstatus tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_kapstatus pctlpts=20 40 60 80 pctlpre=kapstatus_;*/
/*run;*/
/**/
/**/
/*proc univariate data=samle2(where=(kapstatus2=1) keep=indkomst kapstatus2 tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_kapstatus2 pctlpts=20 40 60 80 pctlpre=kapstatus2_;*/
/*run;*/
/**/
/**/
/*proc univariate data=samle2(where=(fradstatus=1) keep=indkomst fradstatus tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_fradstatus pctlpts=20 40 60 80 pctlpre=fradstatus_;*/
/*run;*/
/**/
/**/
/*proc univariate data=samle2(where=(fradstatus2=1) keep=indkomst fradstatus2 tiar) noprint;*/
/*var indkomst;*/
/*by tiar;*/
/*output out=p_fradstatus2 pctlpts=20 40 60 80 pctlpre=fradstatus2_;*/
/*run;*/


/*data ud.tax84_13_&date.(drop=KOM kon amt arledgr top_dummy mellem_dummy bund_dummy notax_dummy*/
/*top_dummy_mec mellem_dummy_mec bund_dummy_mec notax_dummy_mec /*c_aktind akt_1991 akt_1992*/
/*akt_1993 akt_1994 akt_1995 akt_1996 akt_1997 akt_1998 akt_1999 akt_2000 akt_2001 akt_2002 akt_2003 akt_2004 akt_2005*/
/*c_akt_1991 c_akt_1992 c_akt_1993 c_akt_1994 c_akt_1995 c_akt_1996 c_akt_1997 c_akt_1998*/
/*c_akt_1999 c_akt_2000 c_akt_2001 c_akt_2002 c_akt_2003 c_akt_2004 c_akt_2005*/*/
/*arbstatus_20 arbstatus_40 arbstatus_60 arbstatus_80*/
/*arbstatus2_20 arbstatus2_40 arbstatus2_60 arbstatus2_80*/
/*apersstatus_20 apersstatus_40 apersstatus_60 apersstatus_80*/
/*apersstatus2_20 apersstatus2_40 apersstatus2_60 apersstatus2_80*/
/*kapstatus_20 kapstatus_40 kapstatus_60 kapstatus_80*/
/*kapstatus2_20 kapstatus2_40 kapstatus2_60 kapstatus2_80*/
/*fradstatus_20 fradstatus_40 fradstatus_60 fradstatus_80*/
/*fradstatus2_20 fradstatus2_40 fradstatus2_60 fradstatus2_80);*/
/*merge samle2(in=b) p_arbstatus(in=c) p_arbstatus2(in=d) p_apersstatus(in=e) p_apersstatus2(in=f)*/
/*      p_kapstatus(in=g) p_kapstatus2(in=h) p_fradstatus(in=i) p_fradstatus2(in=j)*/
/*p_per_incomestatus(in=k) p_per_incomestatus2(in=l); */
/*by tiar;*/
/**/
/*if indkomst<arbstatus_20 then e1=1;*/
/*if arbstatus_20<=indkomst<arbstatus_40 then e1=2;*/
/*if arbstatus_40<=indkomst<arbstatus_60 then e1=3;*/
/*if arbstatus_60<=indkomst<arbstatus_80 then e1=4;*/
/*if indkomst=>arbstatus_80 then e1=5;*/
/*if indkomst=>arbstatus_90 then e1=6;*/
/**/
/*if indkomst<arbstatus2_20 then e2=1;*/
/*if arbstatus2_20<=indkomst<arbstatus2_40 then e2=2;*/
/*if arbstatus2_40<=indkomst<arbstatus2_60 then e2=3;*/
/*if arbstatus2_60<=indkomst<arbstatus2_80 then e2=4;*/
/*if indkomst=>arbstatus2_80 then e2=5;*/
/**/
/*if indkomst<apersstatus_20 then e3=1;*/
/*if apersstatus_20<=indkomst<apersstatus_40 then e3=2;*/
/*if apersstatus_40<=indkomst<apersstatus_60 then e3=3;*/
/*if apersstatus_60<=indkomst<apersstatus_80 then e3=4;*/
/*if indkomst=>apersstatus_80 then e3=5;*/
/**/
/*if indkomst<apersstatus2_20 then e4=1;*/
/*if apersstatus2_20<=indkomst<apersstatus2_40 then e4=2;*/
/*if apersstatus2_40<=indkomst<apersstatus2_60 then e4=3;*/
/*if apersstatus2_60<=indkomst<apersstatus2_80 then e4=4;*/
/*if indkomst=>apersstatus2_80 then e4=5;*/
/**/
/*if indkomst<kapstatus_20 then e5=1;*/
/*if kapstatus2_20<=indkomst<kapstatus_40 then e5=2;*/
/*if kapstatus2_40<=indkomst<kapstatus_60 then e5=3;*/
/*if kapstatus2_60<=indkomst<kapstatus_80 then e5=4;*/
/*if indkomst=>kapstatus_80 then e5=5;*/
/**/
/*if indkomst<kapstatus2_20 then e6=1;*/
/*if kapstatus2_20<=indkomst<kapstatus2_40 then e6=2;*/
/*if kapstatus2_40<=indkomst<kapstatus2_60 then e6=3;*/
/*if kapstatus2_60<=indkomst<kapstatus2_80 then e6=4;*/
/*if indkomst=>kapstatus2_80 then e6=5;*/
/**/
/*if indkomst<fradstatus_20 then e7=1;*/
/*if fradstatus_20<=indkomst<fradstatus_40 then e7=2;*/
/*if fradstatus_40<=indkomst<fradstatus_60 then e7=3;*/
/*if fradstatus_60<=indkomst<fradstatus_80 then e7=4;*/
/*if indkomst=>fradstatus_80 then e7=5;*/
/**/
/*if indkomst<fradstatus2_20 then e8=1;*/
/*if fradstatus2_20<=indkomst<fradstatus2_40 then e8=2;*/
/*if fradstatus2_40<=indkomst<fradstatus2_60 then e8=3;*/
/*if fradstatus2_60<=indkomst<fradstatus2_80 then e8=4;*/
/*if indkomst=>fradstatus2_80 then e8=5;*/
/**/
/*if indkomst<per_incomestatus_20 then e9=1;*/
/*if per_incomestatus_20<=indkomst<per_incomestatus_40 then e9=2;*/
/*if per_incomestatus_40<=indkomst<per_incomestatus_60 then e9=3;*/
/*if per_incomestatus_60<=indkomst<per_incomestatus_80 then e9=4;*/
/*if indkomst=>per_incomestatus_80 then e9=5;*/
/**/
/*if indkomst<per_incomestatus2_20 then e10=1;*/
/*if per_incomestatus2_20<=indkomst<per_incomestatus2_40 then e10=2;*/
/*if per_incomestatus2_40<=indkomst<per_incomestatus2_60 then e10=3;*/
/*if per_incomestatus2_60<=indkomst<per_incomestatus2_80 then e10=4;*/
/*if indkomst=>per_incomestatus2_80 then e10=5;*/
/**/
/*if b=1 and c=1 and d=1 and e=1 and f=1 and g=1 and h=1 and i=1 and j=1 and k=1 and l=1;*/
/**/
/*rename børn=born lokal_unemp=unem difftax=difftaxable;*/
/*exp2=exp*exp;*/
/*run;*/
/*
OBS: EXPORT AF STATAPROGRAM ER STJERNET UD, DA DET SKER IGEN I "Overførsler";
/*proc export data=ud.tax84_02_&date. file="D:\projekt\Skatteelasticiteter\Data\Estimationsdata\tax84_02_&date..dta" dbms=stata replace;*/
/*run;*/
*/
